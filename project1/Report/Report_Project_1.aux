\relax 
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Mathematical Motivation}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Solution}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Problem Set-Up}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Algorithms}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces The figure above shows the iterative loops that we used in C++ to initialize these quantities and calculate further ones. Note the simplified algorithms were used in our code to reduce floating point operations.}}{4}}
\newlabel{fig:codesample}{{1}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Problem 1c}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Relative Error}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5}LU Decomposition Comparison}{4}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Conclusions}{4}}
\@writefile{toc}{\contentsline {section}{\numberline {4}References}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Plot of Log of Relative Error. On the x-axis, we see the log of the step-size. This is equivalent to looking at which $i$ value we chose to use in order to approximate our solution. The y-axis shows the log of the relative error given in the equation above. What we see is that the log of error has a slope of approximately -2, as expected in our initial mathematic discussion. The error begins to increase again after $i=6$ or $n=10^{6}, h \approx 10^{-6}$. This is due to the truncation error that is getting overwritten by the number of bits. The increase in error can be accounted to machine error.}}{5}}
\newlabel{fig:errorplot}{{2}{5}}
